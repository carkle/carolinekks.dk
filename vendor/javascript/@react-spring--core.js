// @react-spring/core@10.0.0 downloaded from https://ga.jspm.io/npm:@react-spring/core@10.0.0/dist/react-spring_core.modern.mjs

import{is as t,toArray as e,eachProp as s,getFluidValue as n,Globals as i,isAnimatedString as r,useIsomorphicLayoutEffect as o,each as a,easings as c,raf as u,flush as l,FluidValue as h,deprecateInterpolate as d,callFluidObservers as f,frameLoop as p,hasFluidValue as m,flushCalls as g,isEqual as v,getFluidObservers as y,addFluidObserver as _,removeFluidObserver as b,noop as w,deprecateDirectCall as P,useForceUpdate as I,usePrev as k,useOnce as S,useConstant as C,onScroll as x,onResize as R,createInterpolator as j,createStringInterpolator as q}from"@react-spring/shared";export{Globals,createInterpolator,easings,useIsomorphicLayoutEffect,useReducedMotion}from"@react-spring/shared";import*as V from"react";import{useMemo as M,useRef as O,useContext as A,useState as Q}from"react";import{getAnimated as T,AnimatedValue as z,getPayload as N,AnimatedString as E,getAnimatedType as D,setAnimated as U}from"@react-spring/animated";export*from"@react-spring/types";function F(e,...s){return t.fun(e)?e(...s):e}var Y=(s,n)=>s===true||!!(n&&s&&(t.fun(s)?s(n):e(s).includes(n)));var X=(e,s)=>t.obj(e)?s&&e[s]:e;var B=(t,e)=>t.default===true?t[e]:t.default?t.default[e]:void 0;var G=t=>t;var $=(e,s=G)=>{let n=J;if(e.default&&e.default!==true){e=e.default;n=Object.keys(e)}const i={};for(const r of n){const n=s(e[r],r);t.und(n)||(i[r]=n)}return i};var J=["config","onProps","onStart","onChange","onPause","onResume","onRest"];var L={config:1,from:1,to:1,ref:1,loop:1,reset:1,pause:1,cancel:1,reverse:1,immediate:1,default:1,delay:1,onProps:1,onStart:1,onChange:1,onPause:1,onResume:1,onRest:1,onResolve:1,items:1,trail:1,sort:1,expires:1,initial:1,enter:1,update:1,leave:1,children:1,onDestroyed:1,keys:1,callId:1,parentId:1};function W(t){const e={};let n=0;s(t,((t,s)=>{if(!L[s]){e[s]=t;n++}}));if(n)return e}function H(t){const e=W(t);if(e){const n={to:e};s(t,((t,s)=>s in e||(n[s]=t)));return n}return{...t}}function K(e){e=n(e);return t.arr(e)?e.map(K):r(e)?i.createStringInterpolator({range:[0,1],output:[e,e]})(1):e}function Z(t){for(const e in t)return true;return false}function tt(e){return t.fun(e)||t.arr(e)&&t.obj(e[0])}function et(t,e){t.ref?.delete(t);e?.delete(t)}function st(t,e){if(e&&t.ref!==e){t.ref?.delete(t);e.add(t);t.ref=e}}function nt(t,e,s=1e3){o((()=>{if(e){let n=0;a(t,((t,i)=>{const r=t.current;if(r.length){let o=s*e[i];isNaN(o)?o=n:n=o;a(r,(t=>{a(t.queue,(t=>{const e=t.delay;t.delay=t=>o+F(e||0,t)}))}));t.start()}}))}else{let e=Promise.resolve();a(t,(t=>{const s=t.current;if(s.length){const n=s.map((t=>{const e=t.queue;t.queue=[];return e}));e=e.then((()=>{a(s,((t,e)=>a(n[e]||[],(e=>t.queue.push(e)))));return Promise.all(t.start())}))}}))}}))}var it={default:{tension:170,friction:26},gentle:{tension:120,friction:14},wobbly:{tension:180,friction:12},stiff:{tension:210,friction:20},slow:{tension:280,friction:60},molasses:{tension:280,friction:120}};var rt={...it.default,mass:1,damping:1,easing:c.linear,clamp:false};var ot=class{constructor(){this.velocity=0;Object.assign(this,rt)}};function at(e,s,n){if(n){n={...n};ct(n,s);s={...n,...s}}ct(e,s);Object.assign(e,s);for(const t in rt)e[t]==null&&(e[t]=rt[t]);let{frequency:i,damping:r}=e;const{mass:o}=e;if(!t.und(i)){i<.01&&(i=.01);r<0&&(r=0);e.tension=Math.pow(2*Math.PI/i,2)*o;e.friction=4*Math.PI*r*o/i}return e}function ct(e,s){if(t.und(s.decay)){const n=!t.und(s.tension)||!t.und(s.friction);if(n||!t.und(s.frequency)||!t.und(s.damping)||!t.und(s.mass)){e.duration=void 0;e.decay=void 0}n&&(e.frequency=void 0)}else e.duration=void 0}var ut=[];var lt=class{constructor(){this.changed=false;this.values=ut;this.toValues=null;this.fromValues=ut;this.config=new ot;this.immediate=false}};function ht(e,{key:s,props:n,defaultProps:r,state:o,actions:a}){return new Promise(((c,l)=>{let h;let d;let f=Y(n.cancel??r?.cancel,s);if(f)g();else{t.und(n.pause)||(o.paused=Y(n.pause,s));let e=r?.pause;e!==true&&(e=o.paused||Y(e,s));h=F(n.delay||0,s);if(e){o.resumeQueue.add(m);a.pause()}else{a.resume();m()}}function p(){o.resumeQueue.add(m);o.timeouts.delete(d);d.cancel();h=d.time-u.now()}function m(){if(h>0&&!i.skipAnimation){o.delayed=true;d=u.setTimeout(g,h);o.pauseQueue.add(p);o.timeouts.add(d)}else g()}function g(){o.delayed&&(o.delayed=false);o.pauseQueue.delete(p);o.timeouts.delete(d);e<=(o.cancelId||0)&&(f=true);try{a.start({...n,callId:e,cancel:f},c)}catch(t){l(t)}}}))}var dt=(t,e)=>e.length==1?e[0]:e.some((t=>t.cancelled))?mt(t.get()):e.every((t=>t.noop))?ft(t.get()):pt(t.get(),e.every((t=>t.finished)));var ft=t=>({value:t,noop:true,finished:true,cancelled:false});var pt=(t,e,s=false)=>({value:t,finished:e,cancelled:s});var mt=t=>({value:t,cancelled:true,finished:false});function gt(e,n,r,o){const{callId:a,parentId:c,onRest:l}=n;const{asyncTo:h,promise:d}=r;return c||e!==h||n.reset?r.promise=(async()=>{r.asyncId=a;r.asyncTo=e;const f=$(n,((t,e)=>e==="onRest"?void 0:t));let p;let m;const g=new Promise(((t,e)=>(p=t,m=e)));const v=t=>{const e=a<=(r.cancelId||0)&&mt(o)||a!==r.asyncId&&pt(o,false);if(e){t.result=e;m(t);throw t}};const y=(e,n)=>{const c=new yt;const u=new _t;return(async()=>{if(i.skipAnimation){vt(r);u.result=pt(o,false);m(u);throw u}v(c);const l=t.obj(e)?{...e}:{...n,to:e};l.parentId=a;s(f,((e,s)=>{t.und(l[s])&&(l[s]=e)}));const h=await o.start(l);v(c);r.paused&&await new Promise((t=>{r.resumeQueue.add(t)}));return h})()};let _;if(i.skipAnimation){vt(r);return pt(o,false)}try{let s;s=t.arr(e)?(async t=>{for(const e of t)await y(e)})(e):Promise.resolve(e(y,o.stop.bind(o)));await Promise.all([s.then(p),g]);_=pt(o.get(),true,false)}catch(t){if(t instanceof yt)_=t.result;else{if(!(t instanceof _t))throw t;_=t.result}}finally{if(a==r.asyncId){r.asyncId=c;r.asyncTo=c?h:void 0;r.promise=c?d:void 0}}t.fun(l)&&u.batchedUpdates((()=>{l(_,o,o.item)}));return _})():d}function vt(t,e){l(t.timeouts,(t=>t.cancel()));t.pauseQueue.clear();t.resumeQueue.clear();t.asyncId=t.asyncTo=t.promise=void 0;e&&(t.cancelId=e)}var yt=class extends Error{constructor(){super("An async animation has been interrupted. You see this error because you forgot to use `await` or `.catch(...)` on its returned promise.")}};var _t=class extends Error{constructor(){super("SkipAnimationSignal")}};var bt=t=>t instanceof Pt;var wt=1;var Pt=class extends h{constructor(){super(...arguments);this.id=wt++;this._priority=0}get priority(){return this._priority}set priority(t){if(this._priority!=t){this._priority=t;this._onPriorityChange(t)}}get(){const t=T(this);return t&&t.getValue()}to(...t){return i.to(this,t)}
/** @deprecated Use the `to` method instead. */interpolate(...t){d();return i.to(this,t)}toJSON(){return this.get()}observerAdded(t){t==1&&this._attach()}observerRemoved(t){t==0&&this._detach()}_attach(){}_detach(){}_onChange(t,e=false){f(this,{type:"change",parent:this,value:t,idle:e})}_onPriorityChange(t){this.idle||p.sort(this);f(this,{type:"priority",parent:this,priority:t})}};var It=Symbol.for("SpringPhase");var kt=1;var St=2;var Ct=4;var xt=t=>(t[It]&kt)>0;var Rt=t=>(t[It]&St)>0;var jt=t=>(t[It]&Ct)>0;var qt=(t,e)=>e?t[It]|=St|kt:t[It]&=~St;var Vt=(t,e)=>e?t[It]|=Ct:t[It]&=~Ct;var Mt=class extends Pt{constructor(e,s){super();this.animation=new lt;this.defaultProps={};this._state={paused:false,delayed:false,pauseQueue:new Set,resumeQueue:new Set,timeouts:new Set};this._pendingCalls=new Set;this._lastCallId=0;this._lastToId=0;this._memoizedDuration=0;if(!t.und(e)||!t.und(s)){const n=t.obj(e)?{...e}:{...s,from:e};t.und(n.default)&&(n.default=true);this.start(n)}}get idle(){return!(Rt(this)||this._state.asyncTo)||jt(this)}get goal(){return n(this.animation.to)}get velocity(){const t=T(this);return t instanceof z?t.lastVelocity||0:t.getPayload().map((t=>t.lastVelocity||0))}get hasAnimated(){return xt(this)}get isAnimating(){return Rt(this)}get isPaused(){return jt(this)}get isDelayed(){return this._state.delayed}advance(s){let i=true;let r=false;const o=this.animation;let{toValues:a}=o;const{config:c}=o;const u=N(o.to);!u&&m(o.to)&&(a=e(n(o.to)));o.values.forEach(((e,n)=>{if(e.done)return;const l=e.constructor==E?1:u?u[n].lastPosition:a[n];let h=o.immediate;let d=l;if(!h){d=e.lastPosition;if(c.tension<=0){e.done=true;return}let i=e.elapsedTime+=s;const r=o.fromValues[n];const a=e.v0!=null?e.v0:e.v0=t.arr(c.velocity)?c.velocity[n]:c.velocity;let u;const f=c.precision||(r==l?.005:Math.min(1,Math.abs(l-r)*.001));if(t.und(c.duration))if(c.decay){const t=c.decay===true?.998:c.decay;const s=Math.exp(-(1-t)*i);d=r+a/(1-t)*(1-s);h=Math.abs(e.lastPosition-d)<=f;u=a*s}else{u=e.lastVelocity==null?a:e.lastVelocity;const n=c.restVelocity||f/10;const i=c.clamp?0:c.bounce;const o=!t.und(i);const p=r==l?e.v0>0:r<l;let m;let g=false;const v=1;const y=Math.ceil(s/v);for(let t=0;t<y;++t){m=Math.abs(u)>n;if(!m){h=Math.abs(l-d)<=f;if(h)break}if(o){g=d==l||d>l==p;if(g){u=-u*i;d=l}}const t=1e-6*-c.tension*(d-l);const e=.001*-c.friction*u;const s=(t+e)/c.mass;u+=s*v;d+=u*v}}else{let t=1;if(c.duration>0){if(this._memoizedDuration!==c.duration){this._memoizedDuration=c.duration;if(e.durationProgress>0){e.elapsedTime=c.duration*e.durationProgress;i=e.elapsedTime+=s}}t=(c.progress||0)+i/this._memoizedDuration;t=t>1?1:t<0?0:t;e.durationProgress=t}d=r+c.easing(t)*(l-r);u=(d-e.lastPosition)/s;h=t==1}e.lastVelocity=u;if(Number.isNaN(d)){console.warn("Got NaN while animating:",this);h=true}}u&&!u[n].done&&(h=false);h?e.done=true:i=false;e.setValue(d,c.round)&&(r=true)}));const l=T(this);const h=l.getValue();if(i){const t=n(o.to);if(h===t&&!r||c.decay)r&&c.decay&&this._onChange(h);else{l.setValue(t);this._onChange(t)}this._stop()}else r&&this._onChange(h)}set(t){u.batchedUpdates((()=>{this._stop();this._focus(t);this._set(t)}));return this}pause(){this._update({pause:true})}resume(){this._update({pause:false})}finish(){if(Rt(this)){const{to:t,config:e}=this.animation;u.batchedUpdates((()=>{this._onStart();e.decay||this._set(t,false);this._stop()}))}return this}update(t){const e=this.queue||(this.queue=[]);e.push(t);return this}start(e,s){let n;if(t.und(e)){n=this.queue||[];this.queue=[]}else n=[t.obj(e)?e:{...s,to:e}];return Promise.all(n.map((t=>{const e=this._update(t);return e}))).then((t=>dt(this,t)))}stop(t){const{to:e}=this.animation;this._focus(this.get());vt(this._state,t&&this._lastCallId);u.batchedUpdates((()=>this._stop(e,t)));return this}reset(){this._update({reset:true})}eventObserved(t){t.type=="change"?this._start():t.type=="priority"&&(this.priority=t.priority+1)}_prepareNode(e){const s=this.key||"";let{to:i,from:r}=e;i=t.obj(i)?i[s]:i;(i==null||tt(i))&&(i=void 0);r=t.obj(r)?r[s]:r;r==null&&(r=void 0);const o={to:i,from:r};if(!xt(this)){e.reverse&&([i,r]=[r,i]);r=n(r);t.und(r)?T(this)||this._set(i):this._set(r)}return o}_update({...t},e){const{key:s,defaultProps:n}=this;t.default&&Object.assign(n,$(t,((t,e)=>/^on/.test(e)?X(t,s):t)));Et(this,t,"onProps");Dt(this,"onProps",t,this);const i=this._prepareNode(t);if(Object.isFrozen(this))throw Error("Cannot animate a `SpringValue` object that is frozen. Did you forget to pass your component to `animated(...)` before animating its props?");const r=this._state;return ht(++this._lastCallId,{key:s,props:t,defaultProps:n,state:r,actions:{pause:()=>{if(!jt(this)){Vt(this,true);g(r.pauseQueue);Dt(this,"onPause",pt(this,Ot(this,this.animation.to)),this)}},resume:()=>{if(jt(this)){Vt(this,false);Rt(this)&&this._resume();g(r.resumeQueue);Dt(this,"onResume",pt(this,Ot(this,this.animation.to)),this)}},start:this._merge.bind(this,i)}}).then((s=>{if(t.loop&&s.finished&&!(e&&s.noop)){const e=At(t);if(e)return this._update(e,true)}return s}))}_merge(s,i,o){if(i.cancel){this.stop(true);return o(mt(this))}const c=!t.und(s.to);const l=!t.und(s.from);if(c||l){if(!(i.callId>this._lastToId))return o(mt(this));this._lastToId=i.callId}const{key:h,defaultProps:d,animation:f}=this;const{to:p,from:y}=f;let{to:_=p,from:b=y}=s;!l||c||i.default&&!t.und(_)||(_=b);i.reverse&&([_,b]=[b,_]);const w=!v(b,y);w&&(f.from=b);b=n(b);const P=!v(_,p);P&&this._focus(_);const I=tt(i.to);const{config:k}=f;const{decay:S,velocity:C}=k;(c||l)&&(k.velocity=0);i.config&&!I&&at(k,F(i.config,h),i.config!==d.config?F(d.config,h):void 0);let x=T(this);if(!x||t.und(_))return o(pt(this,true));const R=t.und(i.reset)?l&&!i.default:!t.und(b)&&Y(i.reset,h);const j=R?b:this.get();const q=K(_);const V=t.num(q)||t.arr(q)||r(q);const M=!I&&(!V||Y(d.immediate||i.immediate,h));if(P){const t=D(_);if(t!==x.constructor){if(!M)throw Error(`Cannot animate between ${x.constructor.name} and ${t.name}, as the "to" prop suggests`);x=this._set(q)}}const O=x.constructor;let A=m(_);let Q=false;if(!A){const t=R||!xt(this)&&w;if(P||t){Q=v(K(j),q);A=!Q}(v(f.immediate,M)||M)&&v(k.decay,S)&&v(k.velocity,C)||(A=true)}Q&&Rt(this)&&(f.changed&&!R?A=true:A||this._stop(p));if(!I){if(A||m(p)){f.values=x.getPayload();f.toValues=m(_)?null:O==E?[1]:e(q)}if(f.immediate!=M){f.immediate=M;M||R||this._set(p)}if(A){const{onRest:t}=f;a(Nt,(t=>Et(this,i,t)));const e=pt(this,Ot(this,p));g(this._pendingCalls,e);this._pendingCalls.add(o);f.changed&&u.batchedUpdates((()=>{f.changed=!R;t?.(e,this);R?F(d.onRest,e):f.onStart?.(e,this)}))}}R&&this._set(j);I?o(gt(i.to,i,this._state,this)):A?this._start():Rt(this)&&!P?this._pendingCalls.add(o):o(ft(j))}_focus(t){const e=this.animation;if(t!==e.to){y(this)&&this._detach();e.to=t;y(this)&&this._attach()}}_attach(){let t=0;const{to:e}=this.animation;if(m(e)){_(e,this);bt(e)&&(t=e.priority+1)}this.priority=t}_detach(){const{to:t}=this.animation;m(t)&&b(t,this)}_set(e,s=true){const i=n(e);if(!t.und(i)){const t=T(this);if(!t||!v(i,t.getValue())){const e=D(i);t&&t.constructor==e?t.setValue(i):U(this,e.create(i));t&&u.batchedUpdates((()=>{this._onChange(i,s)}))}}return T(this)}_onStart(){const t=this.animation;if(!t.changed){t.changed=true;Dt(this,"onStart",pt(this,Ot(this,t.to)),this)}}_onChange(t,e){if(!e){this._onStart();F(this.animation.onChange,t,this)}F(this.defaultProps.onChange,t,this);super._onChange(t,e)}_start(){const t=this.animation;T(this).reset(n(t.to));t.immediate||(t.fromValues=t.values.map((t=>t.lastPosition)));if(!Rt(this)){qt(this,true);jt(this)||this._resume()}}_resume(){i.skipAnimation?this.finish():p.start(this)}_stop(t,e){if(Rt(this)){qt(this,false);const s=this.animation;a(s.values,(t=>{t.done=true}));s.toValues&&(s.onChange=s.onPause=s.onResume=void 0);f(this,{type:"idle",parent:this});const n=e?mt(this.get()):pt(this.get(),Ot(this,t??s.to));g(this._pendingCalls,n);if(s.changed){s.changed=false;Dt(this,"onRest",n,this)}}}};function Ot(t,e){const s=K(e);const n=K(t.get());return v(n,s)}function At(t,e=t.loop,s=t.to){const n=F(e);if(n){const i=n!==true&&H(n);const r=(i||t).reverse;const o=!i||i.reset;return Qt({...t,loop:e,default:false,pause:void 0,to:!r||tt(s)?s:void 0,from:o?t.from:void 0,reset:o,...i})}}function Qt(e){const{to:s,from:n}=e=H(e);const i=new Set;t.obj(s)&&zt(s,i);t.obj(n)&&zt(n,i);e.keys=i.size?Array.from(i):null;return e}function Tt(e){const s=Qt(e);t.und(s.default)&&(s.default=$(s));return s}function zt(t,e){s(t,((t,s)=>t!=null&&e.add(s)))}var Nt=["onStart","onRest","onChange","onPause","onResume"];function Et(t,e,s){t.animation[s]=e[s]!==B(e,s)?X(e[s],t.key):void 0}function Dt(t,e,...s){t.animation[e]?.(...s);t.defaultProps[e]?.(...s)}var Ut=["onStart","onChange","onRest"];var Ft=1;var Yt=class{constructor(t,e){this.id=Ft++;this.springs={};this.queue=[];this._lastAsyncId=0;this._active=new Set;this._changed=new Set;this._started=false;this._state={paused:false,pauseQueue:new Set,resumeQueue:new Set,timeouts:new Set};this._events={onStart:new Map,onChange:new Map,onRest:new Map};this._onFrame=this._onFrame.bind(this);e&&(this._flush=e);t&&this.start({default:true,...t})}get idle(){return!this._state.asyncTo&&Object.values(this.springs).every((t=>t.idle&&!t.isDelayed&&!t.isPaused))}get item(){return this._item}set item(t){this._item=t}get(){const t={};this.each(((e,s)=>t[s]=e.get()));return t}set(e){for(const s in e){const n=e[s];t.und(n)||this.springs[s].set(n)}}update(t){t&&this.queue.push(Qt(t));return this}start(t){let{queue:s}=this;t?s=e(t).map(Qt):this.queue=[];if(this._flush)return this._flush(this,s);Wt(this,s);return Xt(this,s)}stop(t,s){t!==!!t&&(s=t);if(s){const n=this.springs;a(e(s),(e=>n[e].stop(!!t)))}else{vt(this._state,this._lastAsyncId);this.each((e=>e.stop(!!t)))}return this}pause(s){if(t.und(s))this.start({pause:true});else{const t=this.springs;a(e(s),(e=>t[e].pause()))}return this}resume(s){if(t.und(s))this.start({pause:false});else{const t=this.springs;a(e(s),(e=>t[e].resume()))}return this}each(t){s(this.springs,t)}_onFrame(){const{onStart:t,onChange:e,onRest:s}=this._events;const n=this._active.size>0;const i=this._changed.size>0;if(n&&!this._started||i&&!this._started){this._started=true;l(t,(([t,e])=>{e.value=this.get();t(e,this,this._item)}))}const r=!n&&this._started;const o=i||r&&s.size?this.get():null;i&&e.size&&l(e,(([t,e])=>{e.value=o;t(e,this,this._item)}));if(r){this._started=false;l(s,(([t,e])=>{e.value=o;t(e,this,this._item)}))}}eventObserved(t){if(t.type=="change"){this._changed.add(t.parent);t.idle||this._active.add(t.parent)}else{if(t.type!="idle")return;this._active.delete(t.parent)}u.onFrame(this._onFrame)}};function Xt(t,e){return Promise.all(e.map((e=>Bt(t,e)))).then((e=>dt(t,e)))}async function Bt(e,s,n){const{keys:i,to:r,from:o,loop:c,onRest:l,onResolve:h}=s;const d=t.obj(s.default)&&s.default;c&&(s.loop=false);r===false&&(s.to=null);o===false&&(s.from=null);const f=t.arr(r)||t.fun(r)?r:void 0;if(f){s.to=void 0;s.onRest=void 0;d&&(d.onRest=void 0)}else a(Ut,(n=>{const i=s[n];if(t.fun(i)){const t=e._events[n];s[n]=({finished:e,cancelled:s})=>{const n=t.get(i);if(n){e||(n.finished=false);s&&(n.cancelled=true)}else t.set(i,{value:null,finished:e||false,cancelled:s||false})};d&&(d[n]=s[n])}}));const p=e._state;if(s.pause===!p.paused){p.paused=s.pause;g(s.pause?p.pauseQueue:p.resumeQueue)}else p.paused&&(s.pause=true);const m=(i||Object.keys(e.springs)).map((t=>e.springs[t].start(s)));const v=s.cancel===true||B(s,"cancel")===true;(f||v&&p.asyncId)&&m.push(ht(++e._lastAsyncId,{props:s,state:p,actions:{pause:w,resume:w,start(t,s){if(v){vt(p,e._lastAsyncId);s(mt(e))}else{t.onRest=l;s(gt(f,t,p,e))}}}}));p.paused&&await new Promise((t=>{p.resumeQueue.add(t)}));const y=dt(e,await Promise.all(m));if(c&&y.finished&&!(n&&y.noop)){const t=At(s,c,r);if(t){Wt(e,[t]);return Bt(e,t,true)}}h&&u.batchedUpdates((()=>h(y,e,e.item)));return y}function Gt(s,n){const i={...s.springs};n&&a(e(n),(e=>{t.und(e.keys)&&(e=Qt(e));t.obj(e.to)||(e={...e,to:void 0});Lt(i,e,(t=>Jt(t)))}));$t(s,i);return i}function $t(t,e){s(e,((e,s)=>{if(!t.springs[s]){t.springs[s]=e;_(e,t)}}))}function Jt(t,e){const s=new Mt;s.key=t;e&&_(s,e);return s}function Lt(t,e,s){e.keys&&a(e.keys,(n=>{const i=t[n]||(t[n]=s(n));i._prepareNode(e)}))}function Wt(t,e){a(e,(e=>{Lt(t.springs,e,(e=>Jt(e,t)))}))}var Ht=V.createContext({pause:false,immediate:false});var Kt=()=>{const e=[];const s=function(s){P();const i=[];a(e,((e,r)=>{if(t.und(s))i.push(e.start());else{const t=n(s,e,r);t&&i.push(e.start(t))}}));return i};s.current=e;s.add=function(t){e.includes(t)||e.push(t)};s.delete=function(t){const s=e.indexOf(t);~s&&e.splice(s,1)};s.pause=function(){a(e,(t=>t.pause(...arguments)));return this};s.resume=function(){a(e,(t=>t.resume(...arguments)));return this};s.set=function(s){a(e,((e,n)=>{const i=t.fun(s)?s(n,e):s;i&&e.set(i)}))};s.start=function(s){const n=[];a(e,((e,i)=>{if(t.und(s))n.push(e.start());else{const t=this._getProps(s,e,i);t&&n.push(e.start(t))}}));return n};s.stop=function(){a(e,(t=>t.stop(...arguments)));return this};s.update=function(t){a(e,((e,s)=>e.update(this._getProps(t,e,s))));return this};const n=function(e,s,n){return t.fun(e)?e(n,s):e};s._getProps=n;return s};function Zt(e,s,n){const i=t.fun(s)&&s;i&&!n&&(n=[]);const r=M((()=>i||arguments.length==3?Kt():void 0),[]);const c=O(0);const u=I();const l=M((()=>({ctrls:[],queue:[],flush(t,e){const s=Gt(t,e);const n=c.current>0&&!l.queue.length&&!Object.keys(s).some((e=>!t.springs[e]));return n?Xt(t,e):new Promise((n=>{$t(t,s);l.queue.push((()=>{n(Xt(t,e))}));u()}))}})),[]);const h=O([...l.ctrls]);const d=O([]);d.current??(d.current=[]);const f=k(e)||0;M((()=>{a(h.current.slice(e,f),(t=>{et(t,r);t.stop(true)}));h.current.length=e;p(f,e)}),[e]);M((()=>{p(0,Math.min(f,e))}),n);function p(t,e){for(let n=t;n<e;n++){const t=h.current[n]||(h.current[n]=new Yt(null,l.flush));const e=i?i(n,t):s[n];e&&(d.current[n]=Tt(e))}}const m=h.current.map(((t,e)=>Gt(t,d.current[e])));const g=A(Ht);const v=k(g);const y=g!==v&&Z(g);o((()=>{c.current++;l.ctrls=h.current;const{queue:t}=l;if(t.length){l.queue=[];a(t,(t=>t()))}a(h.current,((t,e)=>{r?.add(t);y&&t.start({default:g});const s=d.current[e];if(s){st(t,s.ref);t.ref?t.queue.push(s):t.start(s)}d.current[e]=null}))}));S((()=>()=>{a(l.ctrls,(t=>t.stop(true)))}));const _=m.map((t=>({...t})));return r?[_,r]:_}function te(e,s){const n=t.fun(e);const[[i],r]=Zt(1,n?e:[e],n?s||[]:s);return n||arguments.length==2?[i,r]:i}var ee=()=>Kt();var se=()=>Q(ee)[0];var ne=(t,e)=>{const s=C((()=>new Mt(t,e)));S((()=>()=>{s.stop()}));return s};function ie(e,s,n){const i=t.fun(s)&&s;i&&!n&&(n=[]);let r=true;let c;const u=Zt(e,((t,e)=>{const n=i?i(t,e):s;c=n.ref;r=r&&n.reverse;return n}),n||[{}]);o((()=>{a(u[1].current,((t,e)=>{const s=u[1].current[e+(r?1:-1)];st(t,c);t.ref?s&&t.update({to:s.springs}):s?t.start({to:s.springs}):t.start()}))}),n);if(i||arguments.length==3){const e=c??u[1];e._getProps=(s,n,i)=>{const r=t.fun(s)?s(i,n):s;if(r){const t=e.current[i+(r.reverse?1:-1)];t&&(r.to=t.springs);return r}};return u}return u[0]}function re(s,n,i){const r=t.fun(n)&&n;const{reset:c,sort:u,trail:l=0,expires:h=true,exitBeforeEnter:d=false,onDestroyed:f,ref:p,config:m}=r?r():n;const g=M((()=>r||arguments.length==3?Kt():void 0),[]);const v=e(s);const y=[];const _=O(null);const b=c?null:_.current;o((()=>{_.current=y}));S((()=>{a(y,(t=>{g?.add(t.ctrl);t.ctrl.ref=g}));return()=>{a(_.current,(t=>{t.expired&&clearTimeout(t.expirationId);et(t.ctrl,g);t.ctrl.stop(true)}))}}));const w=ae(v,r?r():n,b);const P=c&&_.current||[];o((()=>a(P,(({ctrl:t,item:e,key:s})=>{et(t,g);F(f,e,s)}))));const C=[];b&&a(b,((t,e)=>{if(t.expired){clearTimeout(t.expirationId);P.push(t)}else{e=C[e]=w.indexOf(t.key);~e&&(y[e]=t)}}));a(v,((t,e)=>{if(!y[e]){y[e]={key:w[e],item:t,phase:"mount",ctrl:new Yt};y[e].ctrl.item=t}}));if(C.length){let t=-1;const{leave:e}=r?r():n;a(C,((s,n)=>{const i=b[n];if(~s){t=y.indexOf(i);y[t]={...i,item:v[s]}}else e&&y.splice(++t,0,i)}))}t.fun(u)&&y.sort(((t,e)=>u(t.item,e.item)));let x=-l;const R=I();const j=$(n);const q=new Map;const Q=O(new Map);const T=O(false);a(y,((e,s)=>{const i=e.key;const o=e.phase;const a=r?r():n;let c;let u;const f=F(a.delay||0,i);if(o=="mount"){c=a.enter;u="enter"}else{const t=w.indexOf(i)<0;if(o!="leave")if(t){c=a.leave;u="leave"}else{if(!(c=a.update))return;u="update"}else{if(t)return;c=a.enter;u="enter"}}c=F(c,e.item,s);c=t.obj(c)?H(c):{to:c};if(!c.config){const t=m||j.config;c.config=F(t,e.item,s,u)}x+=l;const g={...j,delay:f+x,ref:p,immediate:a.immediate,reset:false,...c};if(u=="enter"&&t.und(g.from)){const i=r?r():n;const o=t.und(i.initial)||b?i.from:i.initial;g.from=F(o,e.item,s)}const{onResolve:v}=g;g.onResolve=t=>{F(v,t);const e=_.current;const s=e.find((t=>t.key===i));if(s&&(!t.cancelled||s.phase=="update")&&s.ctrl.idle){const t=e.every((t=>t.ctrl.idle));if(s.phase=="leave"){const e=F(h,s.item);if(e!==false){const n=e===true?0:e;s.expired=true;if(!t&&n>0){n<=2147483647&&(s.expirationId=setTimeout(R,n));return}}}if(t&&e.some((t=>t.expired))){Q.current.delete(s);d&&(T.current=true);R()}}};const y=Gt(e.ctrl,g);u==="leave"&&d?Q.current.set(e,{phase:u,springs:y,payload:g}):q.set(e,{phase:u,springs:y,payload:g})}));const z=A(Ht);const N=k(z);const E=z!==N&&Z(z);o((()=>{E&&a(y,(t=>{t.ctrl.start({default:z})}))}),[z]);a(q,((t,e)=>{if(Q.current.size){const t=y.findIndex((t=>t.key===e.key));y.splice(t,1)}}));o((()=>{a(Q.current.size?Q.current:q,(({phase:t,payload:e},s)=>{const{ctrl:n}=s;s.phase=t;g?.add(n);E&&t=="enter"&&n.start({default:z});if(e){st(n,e.ref);if(!n.ref&&!g||T.current){n.start(e);T.current&&(T.current=false)}else n.update(e)}}))}),c?void 0:i);const D=e=>V.createElement(V.Fragment,null,y.map(((s,n)=>{const{springs:i}=q.get(s)||s.ctrl;const r=e({...i},s.item,s,n);return r&&r.type?V.createElement(r.type,{...r.props,key:t.str(s.key)||t.num(s.key)?s.key:s.ctrl.id,ref:r.ref}):r})));return g?[D,g]:D}var oe=1;function ae(s,{key:n,keys:i=n},r){if(i===null){const t=new Set;return s.map((e=>{const s=r&&r.find((s=>s.item===e&&s.phase!=="leave"&&!t.has(s)));if(s){t.add(s);return s.key}return oe++}))}return t.und(i)?s:t.fun(i)?s.map(i):e(i)}var ce=({container:t,...e}={})=>{const[s,n]=te((()=>({scrollX:0,scrollY:0,scrollXProgress:0,scrollYProgress:0,...e})),[]);o((()=>{const e=x((({x:t,y:e})=>{n.start({scrollX:t.current,scrollXProgress:t.progress,scrollY:e.current,scrollYProgress:e.progress})}),{container:t?.current||void 0});return()=>{a(Object.values(s),(t=>t.stop()));e()}}),[]);return s};var ue=({container:t,...e})=>{const[s,n]=te((()=>({width:0,height:0,...e})),[]);o((()=>{const e=R((({width:t,height:e})=>{n.start({width:t,height:e,immediate:s.width.get()===0||s.height.get()===0})}),{container:t?.current||void 0});return()=>{a(Object.values(s),(t=>t.stop()));e()}}),[]);return s};var le={any:0,all:1};function he(e,s){const[n,i]=Q(false);const r=O(void 0);const a=t.fun(e)&&e;const c=a?a():{};const{to:u={},from:l={},...h}=c;const d=a?s:e;const[f,p]=te((()=>({from:l,...h})),[]);o((()=>{const e=r.current;const{root:s,once:o,amount:a="any",...c}=d??{};if(!e||o&&n||typeof IntersectionObserver==="undefined")return;const h=new WeakMap;const f=()=>{u&&p.start(u);i(true);const t=()=>{l&&p.start(l);i(false)};return o?void 0:t};const m=e=>{e.forEach((e=>{const s=h.get(e.target);if(e.isIntersecting!==Boolean(s))if(e.isIntersecting){const s=f();t.fun(s)?h.set(e.target,s):g.unobserve(e.target)}else if(s){s();h.delete(e.target)}}))};const g=new IntersectionObserver(m,{root:s&&s.current||void 0,threshold:typeof a==="number"||Array.isArray(a)?a:le[a],...c});g.observe(e);return()=>g.unobserve(e)}),[d]);return a?[r,f]:[r,n]}function de({children:t,...e}){return t(te(e))}function fe({items:e,children:s,...n}){const i=ie(e.length,n);return e.map(((e,n)=>{const r=s(e,n);return t.fun(r)?r(i[n]):r}))}function pe({items:t,children:e,...s}){return re(t,s)(e)}var me=class extends Pt{constructor(t,e){super();this.source=t;this.idle=true;this._active=new Set;this.calc=j(...e);const s=this._get();const n=D(s);U(this,n.create(s))}advance(t){const e=this._get();const s=this.get();if(!v(e,s)){T(this).setValue(e);this._onChange(e,this.idle)}!this.idle&&ve(this._active)&&ye(this)}_get(){const s=t.arr(this.source)?this.source.map(n):e(n(this.source));return this.calc(...s)}_start(){if(this.idle&&!ve(this._active)){this.idle=false;a(N(this),(t=>{t.done=false}));if(i.skipAnimation){u.batchedUpdates((()=>this.advance()));ye(this)}else p.start(this)}}_attach(){let t=1;a(e(this.source),(e=>{m(e)&&_(e,this);if(bt(e)){e.idle||this._active.add(e);t=Math.max(t,e.priority+1)}}));this.priority=t;this._start()}_detach(){a(e(this.source),(t=>{m(t)&&b(t,this)}));this._active.clear();ye(this)}eventObserved(t){if(t.type=="change")if(t.idle)this.advance();else{this._active.add(t.parent);this._start()}else t.type=="idle"?this._active.delete(t.parent):t.type=="priority"&&(this.priority=e(this.source).reduce(((t,e)=>Math.max(t,(bt(e)?e.priority:0)+1)),0))}};function ge(t){return t.idle!==false}function ve(t){return!t.size||Array.from(t).every(ge)}function ye(t){if(!t.idle){t.idle=true;a(N(t),(t=>{t.done=true}));f(t,{type:"idle",parent:t})}}var _e=(t,...e)=>new me(t,e);var be=(t,...e)=>(d(),new me(t,e));i.assign({createStringInterpolator:q,to:(t,e)=>new me(t,e)});var we=p.advance;export{yt as BailSignal,Yt as Controller,Pt as FrameValue,me as Interpolation,de as Spring,Ht as SpringContext,Kt as SpringRef,Mt as SpringValue,fe as Trail,pe as Transition,it as config,H as inferTo,be as interpolate,_e as to,we as update,nt as useChain,he as useInView,ue as useResize,ce as useScroll,te as useSpring,se as useSpringRef,ne as useSpringValue,Zt as useSprings,ie as useTrail,re as useTransition};

